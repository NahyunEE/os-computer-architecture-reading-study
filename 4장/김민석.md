## 4장 - CPU의 작동 원리

<br/>

## CPU - ALU(산술논리연산장치)란?

![이미지](/images/이미지29.PNG)

ALU는 피연산자와 제어신호를 바탕으로 계산을 한다.

- 이유는? ALU는 CPU 내부에 있는 계산을 위한 계산기 같은 회로이기 때문이다.

그 결과를, 레지스터에 담아주게 되는 것이다.

- 결과값은 → 숫자, 문자, 주소값이 될 수도 있다. (본질은 0과 1로 표현된 것)

```jsx
"ALU가 계산한 값을 메모리에 저장하지 않고, 왜 레지스터에 담지?"
```

CPU가 레지스터에 접근하는 속도는, CPU 메모리에 접근하는 속도보다 빠르기 때문이다.

<br/><br/>

## (핵심) 플래그란?

![이미지](/images/이미지30.PNG)

한마디로 정리하면, 연산결과에 대한 부가정보라는 것이다.

CPU가 연산한 결과의 부가 정보로써 이 결과값이 양수인지 음수인지가 결과값과 더불어 또 하나 보낸다고 생각하면 된다.

- e.g.) ALU가 어떤 값을 연산 했는데, 그 결과가 음수라면? → 

    “연산 결과의 값은 음수다” 라고 하는 플래그 값이 플래그 레지스터에 담기게 된다고 생각하면 된다.

```jsx
"오버플로우" -> 만약 ALU의 결과값이 연산을 담을 수 있는 레지스터보다 더 크다면? 
                그 나머지들을 플래그 레지스터에 담게 되는 것이다.
                그리하여, 이것을 "오버플로우" 가 발생 했다고 말합니다.
```

<br/><br/>

## 플래그의 종류

- 부호 플래그 : 연산한 결과의 부호를 나타낸다

    - 1일 경우 음수 / 0일 경우 양수

- 제로 플래그 : 연산 결과가 0인지 여부를 나타낸다.

    - 1일 경우 연산 결과는 0이고 / 0일 경우 연산 결과가 0이 아님을 의미한다.
    
- 캐리 플래그 : 연산결과 올림수나 발림수가 발생했는지를 나타낸다.

    - 1일 경우 올림수나 빌림수가 발했다는 뜻 / 0일 경우 발생하지 않았다는 의미

- 오버플로우 플래그 : 오버플로우가 발생 했는지 나타낸다.

- 인터럽트 플래그 : 인터럽트가 가능한지 나타낸다.

- 슈퍼바이저 플래그 : 커널 모드로 실행 중인지, 사용자 모드로 실행 중인지 나타낸다.

<br/><br/>

## CPU - 제어 장치란?

컴퓨터의 모든 동작을 제어하는 CPU의 핵심 부분이다.

주기억 장치, ALU, I/O 장치에 프로세서가 전송한 명령어를 수행하도록 하는 역할을 한다.

<br/>

### **제어 장치의 기본 기능**

- CPU에 접속 된 장치들에 대한 데이터 이동 순서를 조정한다.

- 명령어를 해독한다.

- CPU 내 데이터 흐름을 제어한다.

- 외부 명령을 받아 일련의 제어 신호를 생성한다.

- CPU에 포함된 많은 실행 장치(ALU, 데이터 버퍼, 레지스터)를 제어 한다.

- 명령어 인출, 명령어 해독, 명령어 실행 등을 순서에 맞추어 처리한다.

<br/>

### **제어 장치의 내부 구성**

```java
- 기억장치 버퍼 레지스터
- 기억장치 주소 레지스터
- 명령 레지스터
- 명령 해독기
- 프로그램 카운터로 구성
```

- 프로그램 카운터를 통해서 다음 명령어를 결정한다.

- 메모리에서 명령을 인출하여 메모리 버퍼 레지스터와 명령 레지스터에 임시 저장한다.

<br/>

### 제어 장치의 종류

- 클록 신호

    - 제어 장치의 동작 타이밍 기준이 되는 신호로서, 하나의 클록 펄스마다 하나의 마이크로 연산 혹은 마이크로 연산의 집합 수행

- 명령어 레지스터

    - 명령어의 연산 코드 필드를 제어 장치에 입력하여 수행해야 할 연산을 결정한다.

- 플래그

    - 중앙처리장치의 상태를 나타내거나 이전 산술 및 논리 연산장치의 연산 결과를 검사한다.


<br/>

### 제어신호

- **제어 버스에서 입력되는 제어 신호** :

    - 인터럽트 처리의 요구 신호 및 확인 신호 등 외부에서 들어오는 제어 신호

- **중앙처리장치로 전달되는 제어 신호** :

    - 레지스터 간 데이터를 전송할 때 발생되며, 특정 산술 및 논리 연산의 기능을 활성화할 때 출력

- **제어 버스를 통해 외부로 출력되는 제어 신호** :

    - 중앙처리장치 밖의 기억장치나 입출력장치 모듈로 보내는 제어 신호

<br/><br/>

## 레지스터란?

![이미지](/images/이미지31.PNG)

레지스터란 개발자한테 중요할 수 있다.

- 개발하고 실행하는 프로그램 속의 명령어와 데이터는 실행 전후로 
그 관련된 값들이 레지스터에 저장되기 때문이다.
- 그리하여 나는 레지스터에 담긴 값들을 관찰할 수가 있다.

<br/><br/>

## 반드시 알아야 할 레지스터 list

프로그램 카운터부터 → 명령어 레지스터까지 순서대로 진행 된다고 보면 된다.

<br/>

## 1) 프로그램 카운터

![이미지](/images/이미지32.PNG)

- 그림에서 보면, 다음 실행할 메모리 주소인 1000번지에 있는 `“1101”`를 실행 할 것이라고 생각하면 되는 것이다. (다음 실행할 주소 저장)

- 메모리에서 가져올 명령어의 주소

- 즉, 다음으로 메모리에서 뭘 읽어드릴지 메모리에서 읽어드릴 명령어의 주소를 저장한다.

<br/><br/>

## 2) 메모리 주소 레지스터

이미지 1)

![이미지](/images/이미지33.PNG)

<br/><br/>

메모리의 주소를 저장한다. (CPU가 주소버스를 이용해야 될 경우)

이미지 2)

![이미지](/images/이미지34.PNG)

- 이미지 1처럼, 1000번지를 메모리로 부터 읽어 와야 할 것이다. 즉, CPU로 가져와야 한다는 것

    - CPU가 메모리로 부터 어떤 주소값을 읽어드리려면, 주소 버스를 이용해서 읽어드리고자 하는 그 주소를 메모리한테 보내줘야 하는것이다.

    - 그러기 위해서는, 주소 버스를 통해서 읽고자 하는 주소를 메모리한테로 쏴줘야 하는 것이다.

    - 그런 작업을 하기 전에, → 메모리 주소 레지스터를 거친다는 것이다.

    - 결론은, 프로그램 카운터에 저장되어 있는 것을, ‘다음’으로 읽어 드릴 주소값은 메모리 주소 레지스터로 복사가 된다는 것이다.

```java
"CPU가 주소버스로 내보낼 주소는 메모리 주소 레지스터를 거친다고 보면 된다"
```

<br/><br/>

## 3) 메모리 버퍼 레지스터

![이미지](/images/이미지35.PNG)

그렇다면, 메모리는 1000번지 저장된 값을 메모리 버퍼 레지스터로 데이터 버스를 통해 전달해주게 되는 것이다.

```jsx
"그리고 중요한 것은, 프로그램 카운터가 1증가 하게 된다는 것이다"
 - 이유는? -> 1000주소 번지를 가져 왔으니, 다음으로 실행시켜야 할 번지는 
              1001번지 주소인것이다. 이렇게 프로그램을 순차적으로 실행 시킬 수 있다

"하지만, 프로그램 카운터가 마냥 증가하는 것은 아니다"
 - 순차적인 실행 흐름이 끊기는 경우도 발생한다
 - 특정 메모리 주소로 실행 흐름을 이동하는 명령어 실행 시
 - jump, call, return, 인터럽트 .. 등
```

- 메모리와 주고 받을 값, 즉 데이터 명령어를 저장한다.

- CPU가 어떤 데이터나 명령어를 데이터버스로 주고 받을대 거치는 레지스터가 메모리 버퍼 레지스터 이다.

- CPU가 데이터 버스로 주고받을 정보 즉, 데이터와 명령어는 메모리 버퍼 레지스터를 거친다

<br/><br/>

## 4) 명령어 레지스터

![이미지](/images/이미지36.PNG)

제어장치가 해석하기 위해서 메모리 버퍼 레지스터에 있는 것을 명령어 레지스터에 복사하게 되는 것이다.

- 해석할 명령어를 저장한다.

- 방금 메모리에서 읽어드린 CPU로 이미 읽어드린 명령어를 저장한다고 생각하자.

<br/><br/>

## 5) 플래그 레지스터

연산 결과 또는 CPU 상태에 대한 부가적인 정보

- 플래그란? → CPU가 계산한 결과에 대한 부가 정보이다.

- 연산 결과, CPU 상태에 대한 부가적인 정보를 저장하고 있는 레지스터이다
- 이것들을 저장하는 레지스터가 플래그 레지스터라고 보면 된다.

```java
"플래그 레지스터를 읽으면, 현재 CPU가 어떤 연산을 하고 있었는지,"
"CPU 상태는 어떤지 파악할 수가 있다"
```

<br/><br/>

## 6) 범용 레지스터

다양하고 일반적인 상황에서 자유롭게 사용 가능한것.

- 메모리 주소 레지스터에는 주소만 담을 수 있고, 메모리 버퍼 레지스터에는 데이터만 담을 수 있다면 범용 레지스터는 둘다 담을 수 있는 것이다.

<br/><br/>

## 7) 스택 포인터 (=스택 주소 지정 방식)

![이미지](/images/이미지37.PNG)

스택이 어디까지 채워져 있는지에 대한 표시이다

스택 주소 지정 방식 : 스택과 스택 포인터를 이용한 주소 지정 방식을 말한다.

스택 포인터란? 스택의 꼭대기를 가리키는 레지스터를 말한다.

```java
"스택은 어디에 있나요?"
 -> 스택은 메모리 안에 있다. 즉, 메모리 안에 스택 처럼 쓸 수 있는 공간이 정해져 있다.
```

<br/><br/>

## 8) 베이스 레지스터 (= 변위 주소 지정 방식)

![이미지](/images/이미지38.PNG)

오퍼랜드 필드의 값과 특정 레지스터의 값을 더하여 유효 주소값을 얻는다.

- 담기는 값의 기준으로부터 얼마나 떨어져 있는지가 이 오퍼랜드의 필드 기준이다

특정 레지스터를 이용해서 할 수 있는 주소 지정 방식에서 스택 포인터와 베이스 레지스터가 사용된다고 보면 된다. 

(뒤에서 추가 설명)

<br/><br/>

## 중요) 명령어 사이클과 인터럽트

cpu는 메모리에 있는 프로그램을 정해진 흐름대로만 처리하는데, 간혹 그 정해진 흐름을 방해, 즉, 끊는 신호를 바로 인터럽트라고 부른다.

<br/><br/>

## 명령어 사이클

프로그램 속 명령어들은 일정한 주기가 반복되며 샐행 된다.

- 이 주기를 명령어 사이클이라고 부른다.

- 인터럽트 사이클은 일단, 무시하기

![이미지](/images/이미지39.PNG)

```java
- 인출 사이클: 가장 먼저 메모리에서 CPU로 갖고 오는 작업을 말한다.
- 간접 사이클: 인출은 했지만, 메모리에 추가로 데이터가 더 필요한 경우를 말한다.
  - 메모리에 추가 작업이 끝나고, 실행이 가능한 상태가 되면 실행 사이클로 되돌아간다.
- 실행 사이클: 메모리에서부터 가지고 왔으면, 실행해야 한다.

CPU는: 인출 사이클 -> 실행 사이클 -> 인출 사이클 -> 실행 사이클을 반복한다.
```

<br/><br/>

## 인터럽트

위 사진처럼 정해진 흐름따라 가는데, 흐름을 끊어 버리는것이 인터럽트이다.

- 방해하다, 중단시키다
- ‘CPU가 꼭 주목해야 할 때’, ‘CPU가 얼른 처리해야 할 다른 작업이 생겼을 때’ 발생한다.

```java
e.g.) "강대리, 이거 급한 거니까, 지금 하던 일 멈추고 이것부터 처리해"
```

<br/><br/>

## 인터럽트 두가지

- 동기 인터럽트(=예외) : cpu가 예기치 못한 상황을 접했을 때 발생한다.

    - 폴트, 트랩, 중간, 소프트웨어 인터럽트 네가지 종류가 있다.

- 비동기 인터럽트(=하드웨어 인터럽트) : 주로 입출력장치에 의해 발생하는 것이다.

    - 알림 - 세탁기 완료 알림, 전자레인지 조리 알림과 같은 역할이다.

<br/>

### 동기 인터럽트(=예외)

![이미지](/images/이미지40.PNG)

- e.g.) 디버깅

<br/><br/>

## 비동기 인터럽트(=하드웨어 인터럽트)

알림과 같은 인터럽트, 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 하드웨어 인터럽트를 사용한다.

![이미지](/images/이미지41.PNG)

<br/>

### 비동기 인터럽트 e.g.)

![이미지](/images/이미지42.PNG)

<br/>

## 비동기 인터럽트를 왜 사용하는데?

인터럽트가 없는 경우, 밑에 사진 처럼 계속 하드웨어가 끝났는지 계속 물어봐야 하는 것이다.

![이미지](/images/이미지43.PNG)

<br/>

하지만, 인터럽드가 있다면 나 다른일 하고 있을 테니깐 알림으로 알려줘. 하는 것처럼 다른일을 할 수 있는 것이다.

![이미지](/images/이미지44.PNG)

```java
"왜? 존재하는거야?"
cpu가 입출력 작업 도중에도, 효율적으로 명령어를 처리하기 위해서 사용한다.
```

<br/><br/>

## 인터럽트에 대한 용어 정리

- 인터럽트 요청 신호

- 인터럽트 플래그

- 인터럽트 백터

- 인터럽트 서비스 루틴

<br/>

### 인터럽트 요청 신호

![이미지](/images/이미지45.PNG)

인터럽트를 보내는 입출력 장치 같은, 주체들이 CPU한테 지금 끼어들어도 돼요? 라고 요청을 보내는 신호를 인터럽트 요청이라고 부른다.

- 인터럽트는 CPU의 정상적인 실행 흐름을 끊는 것이기 때문에 항상 이런식으로 인터럽트를 보내는 주체는 인터럽트 요청 신호를 CPU한테 보내게 되는 것이다.

<br/>

### 인터럽트 플래그

![이미지](/images/이미지46.PNG)

0과 1로 표현 → 현재 인터럽트를 받아 드릴 수 있는지, 없는지

<br/>

### 인터럽트 서비스 루틴

![이미지](/images/이미지47.PNG)

CPU가 인터럽트를 받아들이기로 했다면, 인터럽트 서비스 루틴을 실행한다.

- 인터럽트 서비스 루틴은, 메모리 안에 있는 프로그램이다. (즉, 메모리에 저장)

- 인터럽트가 발생했을 때, 해당 인터럽트를 어떻게 처리하기 위한 프로그램이다.

    - e.g.) “키보드가 인터럽트 요청을 보내면 이렇게 행동하세요!” 느낌

    - e.g.) “마우스가 인터럽트 요청을 보내면 이렇게 행동하세요!” 느낌

<br/>

### 인터럽트 백터

![이미지](/images/이미지48.PNG)

인터럽트를 보낼 수 있는 주체에 따라서 인터럽트 서비스 루틴의 시작 주소가 달라 질 수 있는데,

CPU가 해당 인터럽트 서비스 루틴의 시작 주소는 무엇인지, 그 인터럽트를 구분할 수 있는 정보가 필요하다. 그것이 바로 인터럽트 백터이다.

<br/><br/>

## CPU가 인터럽트를 처리한다는 말은?

‘인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아 온다’ 는 뜻이 된다.

- 그리고 인터럽트의 시작 주소는 인터럽트 백터를 통해 알 수 있다

<br/><br/>

## 문제점!

![이미지](/images/이미지49.PNG)

현재, 레지스터에는 값들이 저장되어 있는 상태이다. 

그리고, 10번지에 있는 인터럽트 서비스 루틴을 실행하게 된다면 → 

프로그램 카운터에 1500번지에 들어 있는것을 삭제 시켜버리고, 10번지 주소를 넣어야 될까?

- 정답은 절대 안된다! → 

    왜냐면 언제든 다시 되돌아와서 수행을 재개해야 하기 때문에 현재 레지스터에는 
    
    어떤 값들이 담겨 있는지 현재 CPU는 어떤 상태인지가 다 기억이 되어야 한다는 것이다.

```java
현재 레지스터에 저장되어 있는 것들에 대해 백업을 해둬야 하는 것인데,
 - "이것들을 모두 스택에 백업 해두게 된다"
```

![이미지](/images/이미지50.PNG)

<br/><br/>

## 비동기 인터럽트 처리 순서

1. 입출력장치는 CPU에 인터럽트 요청 신호를 보낸다

2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.

3. CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다.

4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다

5. CPU는 인터럽트 백터를 참조하여 인터럽트 서비스 루틴을 실행한다.

6. 인터럽트 서비스 루틴 실행이 끝나면 4에서 백업해 둔 작업을 복구 하여 실행을 재개한다.

```java
- 인터럽트 요청 신호: CPU의 작업을 방해하는 인터럽트에 대한 요청
- 인터럽트 플래그: 인터럽트 요청 신호를 받아들일지 무시할지를 결정하는 비트
- 인터럽트 백터: 인터럽트 서비스 루틴의 시작 주소를 포함하는 인터럽트 서비스 루틴의 식별 정보
- 인터럽트 서비스 루틴: 인터럽트를 처리하는 프로그램
```