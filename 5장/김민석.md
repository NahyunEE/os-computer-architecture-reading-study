## 5장. CPU의 성능 향상 기법

<br/>

## 빠른 CPU를 위한 설계 기법

```java
"조금이라도 더 빠른 CPU를 만들고 싶다면 어떻게 해야 될까?"
```

- 단순하게 생각하면 클럭 신호를 빠르게 하는 방법이 있을 것이다.

- CPU는 명령어 사이클이라는 정해진 흐름에 맞춰서 명령어들을 실행한다.

- 클럭 신호에 맞춰서 일사분란하게 움직이니까, 이 클럭 신호, 자체를 빠르게 반복하면 될 것이다.

그렇기에, 클럭 속도는 CPU의 속도 단위로 간주되기도 한다.

<br/><br/>

## CPU를 마냥 높이면 마냥 빨라 질까?

답변으로는 꼭 그렇진 않다.

- 필요 이상으로 클럭을 높이면, 발열이 생기기에 조심해야 되는 것이다.

```java
"클럭 속도를 늘리는 방법 이외에 CPU를 조금 더 빠르게 동작 시킬 수 있는 방법을 찾아야 한다"
```

- 코어 수를 늘리는 방법(e.g. 듀얼 코어, 멀티 코어 .. 등)
- 스레드 수를 늘리는 방법(e.g. 멀티 스레드, .. 등)

<br/><br/>

## 코어 & 멀티코어 란?

![이미지](/images/이미지51.PNG)

CPU 안에서 명령어를 인출하고 해석하고 실행하는 부품을 오늘날 코어라고한다.

cpu 내에서 명령어를 실행하는 부품으로 cpu 즉, 프로세스 안에 여러개 있을 수 있게 된것이다.

- 요즘은 CPU에는 명령어를 실행하는 부품이 여러 개 존재한다.

    - 명령어를 실행하는 부품을 코어라는 용어로 사용한다.

    - 또한 두 개 이상의 코어를 갖고 있는 CPU를 멀티코어 라고 부른다.

<br/>

```java
"코어를 2개, 3개, 5개, 9개, 50개로 늘리면 연산 속도가 그 만큼 빨라질까?"
```

- 그렇진 않다. → 꼭 코어수에 비례해서 속도가 증가하는 건 아니란 것이다.

- 조별 과제를 생각해보면 쉽다. → 인원이 많다고 마냥 빠른게 아니다.

<br/><br/>

## 스레드 & 멀티 스레드 란?

하나의 프로그램에서 독립적으로 실행되는 단위를 의미합니다.

<br/>

### e.g.) 워드 프로세스 프로그램을 설계 하였다.

밑 3가지 과정을들 순차적으로 진행하는 것이 아니라, 동시에 실행 되도록 하고 싶다면?

1. 사용자로부터 입력받은 내용을 화면에 보여 주는 기능

2. 사용자가 입력한 내용이 맞춤법에 맞는 검사하는 기능

3. 사용자가 입력한 내용을 수시로 저장하는 기능

```java
"실행 되는 단위(스레드)를 3개 만들어서 각각 실행 되게 하면 3개가 동시에 실행된다"
```

하지만 펙트는, CPU는 내부적으로 여러개의 프로그램이나 스레드를 실행 할때, 엄청나게 빠르게 번갈아가며 실행되기 때문에 이게 마치 동시에 실행되는 것처럼 사용자 눈에는 보이게 실행을 해주기 때문이다.

![이미지](/images/이미지52.PNG)

<br/><br/>

## 명령어 병렬 처리 기법

CPU를 빠르게 처리할 수 있도록 설계하는 것도 중요하지만,

 CPU가 시간 낭비 없이 시간을 사용하면서 메모리에 있는 명령어들을 빠르게 실행할 수 있는지도 중요하다

<br/><br/>

## 중요) 명령어 파이프라인

명령어 파이프라인은 여러 개의 명령어를 겹쳐서 실행하는 방법이라고 볼 수 있다.

명령어가 처리되는 과정을 비슷한 시간 간격을 나누면?

1. 명령어 인출

2. 명령어 해석

3. 명령어 실행

4. 결과 저장

![이미지](/images/이미지53.PNG)

여기서 중요한 것은, 같은 단계가 겹치치만 않으면 CPU는 각각의 단계를 동시에 실행 할 수 있다는 것이다. 

→ 이것이 바로 명령어 파이프라인 이라는 것이다.

<br/><br/>

### 명령어 파이프라인을 사용하지 않는다면?

![이미지](/images/이미지54.PNG)

한눈에 봐도, 시간이 정말 길어진다는 것을 알 수 있다.

<br/><br/>

## 명령어 파이프라인이 실패 하는 경우

동시에 명령어를 처리할 수 없는 경우도 있다 → 그것을 파이프라인 위험 or 파이프라인 해저드라고 부른다.

- 데이터 위험

- 제어 위험

- 구조적 위험

<br/>

### 데이터 위험

명령어 간의 의존성 때문에 생겨나는 위험이다.

즉, 명령어 끼리의 의존성이 있어서 명령어를 병렬로 처리할 수 없는 상황을 데이터 위험이라고 한다.

- 모든 명령어를 동시에 처리할 수는 없다.

- 이전 명령어를 끝까지 실행해야만 비로소 실행할 수 있는 경우이다.

<br/>

### 제어 위험

![이미지](/images/이미지55.PNG)

프로그램 카운터의 갑작스러운 변화 때문에 생겨나는 위험이다.

- 프로그램 카운터가 갑작스럽게 어떤 특정 메모리 주소로 변경하는 명령어 들이 있다.
    - 점프 등등..

<br/>

### 구조 위험

ALU, 레지스터 등을 쓰려고 할때 발생하는 위험이다.

<br/><br/>

## 슈퍼스칼라

한번에 여러 개의 명령어를 인출하고 해석하고 실행하고 저장하는 구조를 겹쳐서 실행 할 수 있는 구조를 말하는 것이다.

- 이론적으로 파이프라인 개수에 비례하여 처리 속도가 증가한다.

- But 파이프라인 위험도의 증가로 인해

- 파이프라인 개수에 비례하여 처리 속도가 증가하진 않는다.

![이미지](/images/이미지56.PNG)

<br/><br/>

## CISC(=시스코) 와 RISC(=리스크)

CISC : 복잡한 명령어 집합을 활용하는 컴퓨터(=CPU)라고 말한다. (가변 길이 명령어 집합)

- CISC 는 명령어 하나하나가 굉장히 강력한 기능들을 제공한다. 

    그리고 이러한 명령어 자체도 그 개수도 다양하기 때문에 상대적으로 적은 수의 명령어만으로도 프로그램을 실행 할 수가 있다.

```java
"명령어 파이프라인이 불리하다는 단점이 있다"
 - 또한, 복잡한 명령어들은 사용 빈도가 낮다.
```

<br/><br/>

## CISC의 문제 속에서 주목 받은 것이 RISC이다.

명령어의 종류가 적고, 명령어도 짧고 규격화된 명령어를 사용한다.

- 리스크는 단순하고 적은 수의 명령어들을 지원한다는 것이다.

- 고정 길이의 명령어 집합을 활용한다.

- 리스크는 시스크에 비해 비교적 짧고 규격화된 명령어들을 활요하기 때문에 시스크에 비해서 명령어 파이프라인에 유리하다는 장점이 있다.

```java
"리스크 같은 경우는 메모리 접근 방식을 최소화하는 경우가 많다"
 - 이유는? 리스크 자체가 메모리 접근을 최소화하는 대신 레지스터를 10분 활용하는 방식이기 때문
```

<br/><br/>

## 정리

### CISC

- 복잡하고 다양한 명령어

- 가변 길이 명령어

- 다양한 주소 지정 방식

- 프로그램을 이루는 명령어의 수가 적음

- 여러 클럭에 걸쳐 명령어를 수행

- 파이프라이닝 하기 어렵다

<br/>

### RISC

- 단순하고 적은 명령어

- 고정 길이 명령어

- 적은 주소 지정 방식

- 프로그램을 이루는 명령어의 수가 많음

- 1클럭 내외로 명령어 수행

- 파이프라이닝 하기 쉬움