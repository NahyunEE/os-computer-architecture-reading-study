# CPU 성능 향상 기법

# 1. 빠른 CPU를 위한 설계 방법

## 클럭

- 컴퓨터 부품들은 `클럭 신호` 에 맞춰 동작함
- CPU는 ‘명령어 사이클’에 맞추어 명령어를 실행함
- CPU 클럭의 속도는 유연하게 조절함
- 클럭 속도를 올리면 CPU가 빨라질 수 있지만 
클럭 속도만으로 CPU의 성능을 향상시키는 것은 한계가 있음

## 코어

- 코어 : 명령어를 실행하는 부품 (=CPU의 정의)
    
    → CPU : 명령어를 실행하는 부품을 여러 개 포함하는 부품
    
- 멀티코어 CPU, 멀티코어 프로세서 : 코어를 여러 개 포함하고 있는 CPU
- 코어를 늘린다고 무조건 CPU 성능이 좋아지지 않음 
→ 코어마다 처리할 명령어들을 얼마나 **적절하게 분배**하느냐가 중요함

## 스레드

### 하드웨어 스레드

- 하나의 코어가 동시에 처리하는 명령어 단위
- 멀티스레드 프로세서, 멀티스레드 CPU : 하나의 코어로 여러 명령어를 동시에 처리하는 CPU

### 소프트웨어 스레드

- 하나의 프로그램에서 독립적으로 실행되는 단위

# 2. 명령어 병렬 처리 기법

## 명령어 병렬 처리 기법

- 명령어를 동시에 처리하여 CPU가 쉬지 않고 작동시키는 방법

## 명령어 병렬 처리 기법의 종류

- 명령어 처리 과정 
: 명령어 인출 → 명령어 해석 → 명령어 실행 → 결과 저장

### 명령어 파이프라인 
![](https://velog.velcdn.com/images/sukk/post/a07b8b3b-bb34-4e2e-af1b-071d687c7eb3/image.png)


- 같은 단계가 겹치지만 않는다면 CPU는 동시에 여러 단계의 작업을 수행할 수 있음
- 하나의 명령어가 끝날 때까지 기다렸다가 다른 명령어를 수행하는 것 보다
    
    각각의 명령어 단계들을 동시에 각 단계를 수행하도록하는 것이 효율적
    
- 하지만 특정 상황에서는 성능 향상에 실패하는 경우도 있음 → `파이프라인 위험`

**`파이프라인 위험`**

- 데이터 위험
    - 명령어 간의 ‘데이터 의존성’에 의해 발생
        - 아래 두 명령어에서 명령어2는 명령어1이 처리되어야 수행할 수 있음
            
            <aside>
            📌 명령어: R1 ← R2 + R3
            명령어: R5 ← R1 + R4
            
            </aside>
            
- 제어 위험
    - 프로그램 카운터의 갑작스러운 변화에 의해 발생
        - 프로그램 실행 흐름이 바뀌어 갑자기 다른 메모리 주소로 분기한다면 
        **동시에 실행되고 있던(완료된) 명령어 단계들은 쓸모없어짐**
    - 이를 위해 분기 예측 프로그램을 활용함
- 구조적 위험
    - 서로 다른 명령어가 동시에 같은 CPU 부품을 사용하려고 할 때 발생
    - 자원 위험(resource hazard) 라고도 함

### 슈퍼스칼라
![](https://velog.velcdn.com/images/sukk/post/06c10278-c4cd-4d00-bf12-85116c198104/image.png)


- 여러 개의 명령어 파이프라인을 두는 구조
- 이론적으로는 파이프라인 개수에 비례하여 처리 속도가 빨라져야함
- 하지만 파이프라인 개수에 비례하여 **파이프라인 위험도 증가**하여 CPU 성능이 파이프라인 개수에 비례하진 않음

### 비순차적 명령어 처리


```
1. M(100) ← 1
2. M(101) ← 2
3. M(102) ← M(100) + M(101) - 이 명령어는 명령어 1, 2번이 처리될 때까지 기다려야 함
4. M(150) ← 1
5. M(151) ← 1
6. M(152) ← 1
```
![](https://velog.velcdn.com/images/sukk/post/bc64d9b1-41d2-4055-a33a-a81920e5db8d/image.png)
```
1. M(100) ← 1
2. M(101) ← 2
3. M(150) ← 1
4. M(151) ← 1
5. M(152) ← 1
36 M(102) ← M(100) + M(101) - 이 순서로 수행하면 기다릴 필요가 없음
```
![](https://velog.velcdn.com/images/sukk/post/36e14a68-947d-4869-8cbe-be72f5b8e549/image.png)



- 이렇게 명령어를 순차적으로 실행하지 않고 
순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 (의존성이 없는 데이터만 순서 변경 가능)
명령어 파이프라인이 멈추는 것을 방지하는 기법이 **비순차적 명령어 처리 기법**

# 3. CISC와 RISC

## ISA

- ISA (Instruction Set Architecture) - 명령어 집합 구조
    - CPU가 이해할 수 있는 명령어들의 모음 (어셈블리어) ⇒ CPU의 언어
    - 제조사마다 CPU가 다르고 CPU가 이해하고 사용하는 명령어들이 다름
- ISA가 달라지면 사용되는 레지스터의 종류와 개수, 메모리 관리 방법 등 많은 것들이 달라짐
- 명령어 병렬 처리 기법에 유리한 ISA는 CISC와 RISC중 무엇일까?

 

## CISC

- CISC (Complex Instruction Set Computer) - 복잡한 명령어 집합을 활용하는 컴퓨터
    - 가변길이 명령어 활용
        - 다양하고 강력한 기능의 명령어 집합 → 명령어의 형태와 크기가 다양함
    - 상대적으로 적은 수의 명령어로 프로그램을 실행할 수 있음
    - 명령어 하나를 실행하는데에 여러 클럭 주기가 필요함
        - 명령어의 크기와 실행되기까지의 시간이 일정하지 않음
        - 파이프라인을 구현하는게 어려움
    - 다양한 명령어가 있긴 하지만 소수의 명령어가 자주 사용됨

## RISC

- RISC (Reduced Instruction Set Computer) - 감소된(?) 명령어 집합을 활용하는 컴퓨터
    - 명령어의 길이와 수행시간이 짧고 규격화되도록
        - 고정 길이 명령어 사용
    - 자주 쓰이는 기본적인 명령어를 작고 빠르게 만들기
        - 명령어의 종규가 적음
    - 메모리 접근을 최소화하는 대신 레지스터 활용 
    → 레지스터를 이용하는 연산이 많고 범용 레지스터 개수도 많음

![](https://velog.velcdn.com/images/sukk/post/8c109acf-f38d-4e66-bec4-dfbea3fd4472/image.png)


> ### Reference
혼자 공부하는 컴퓨터 구조 + 운영체제 강의 (인프런) - 사진 출처