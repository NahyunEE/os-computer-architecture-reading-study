## 명령어

자바, C, C++, 파이썬 같은 프로그래밍 언어들은 고급언어라고 부른다.

- 고급언어란 개발자가 읽고 쓰기 편하게 만들어진 언어이다.

```jsx
고급언어가 컴퓨터 내부에서 실행 될때는, 고급언어가 -> 저급 언어로 변환 되어서 실행된다.
```

<br/>

## 저급언어의 두가지

- 기계어

- 어셈블리어

<br/>

### 기계어란 → 0과 1로만 표현된 것.

![이미지](/images/이미지23.PNG)

<br/>

### 어셈블리어란?

기계어를 사람들이 읽고 쓰기 편하도록 번역한 저급 언어이다.

![이미지](/images/이미지24.PNG)

<br/><br/>

## 고급 언어란?

고급언어가 → 저급언어로 변환 되는 과정에는 크게 두가지가 있다.

![이미지](/images/이미지25.PNG)

<br/>

### 컴파일 언어란?

결국 컴퓨터가 이해할 수 있는 저급 언어로 변환된다고 이해하면 된다.

![이미지](/images/이미지26.PNG)


<br/>

### 인터프리트 언어란?

인터프리터 : 한줄씩 저급 언어로 변환해 실행해주는 도구

인터프리터라고 하는 특수한 프로그램에 의해서, 소스 코드를 한줄 한줄 실행해 주는 프로그래밍 언어를 의미한다.

- 소스 코드 전체가 저급 언어로 변환되기 까지 기다릴 필요가 없다.

- e.g.) Python

<br/><br/>

## 차이를 보자.

컴파일 언어 같은 경우, 소스 코드를 컴파일 하게 되면(실행파일로 만들어 주는 역할) 

내 소스 코드 전체를 컴퓨터가 이해 할 수 있는 저급 언어로 전부 변환해 준다는 것이다. 

<br/>

하지만 인터프리터 같은 언어는 한줄씩 한줄씩 저급언어로 변환 시키기에 

소스 코드 전체가 저급언어로 변환되기 까지 기다릴 필요가 없다는 것이다.

<br/>


일반적으로 인터프리터언어는 컴파일언어보다 느리다. 
 
자바같은경우는 인터프리터와 컴파일러를 둘다 사용 한다.


<br/><br/>



## 목적파일 vs 실행파일


목적파일 : 목적 코드로 이루어진 파일

실행파일 : 실행 코드로 이루어진 파일

<br/>

목적코드는 컴퓨터가 이루어진 저급 언어이기 떄문에,

실행될수 있는 실행파일이 되기 위해 링킹이라는 작업을 거친다. 



<br/><br/>

## 오류가 있다면?

![이미지](/images/이미지27.PNG)

- 컴파일 언어는 오류가 있다면, 코드 전체가 실행 되지 않는다.

- 인터프리터 언어는 오류 발생 전까지의 코드는 실행 가능하다.

<br/><br/>

## 명령어의 구조

- 연산코드

- 오퍼랜드

```jsx
- "학생들, 다음 주까지 과제 제출하세요"
- "영수야, 방 좀 치워 줘"
- "멍멍아, 이거 물어와!"
```

<br/>

## 오퍼랜드란?

연산코드가 어떤 연산을 하느냐에 따라 오퍼랜드가 1개일수도, 2개일수도, 없을수도 있다


- 연산에 사용될 데이터

- 연산에 사용될 데이터가 저장된 위치

오퍼랜드의 개수가 두개인 경우도 있고, `하나인 경우도 있고, 하나도 없는 경우도 있다.`

- 여기서 오퍼랜드는 → “eax” , “0” , “rbp” 를 말한다.

- 그렇다면, 연산 코드는? → “mov” , “pop” , “ret”

![이미지](/images/이미지28.PNG)

<br/><br/>

## 연산 코드란?

대표적인 네가지.

- 데이터 전송

- 산술 / 논리 연산

- 제어 흐름 변경

- 입출력 제어

<br/><br/>

## 데이터 전송

- MOVE : 데이터를 옮겨라. → 레지스터에서 다른 레지스터로 옮겨라.

- STORE : 메모리에 저장하라

- LOAD : 메모리에서 CPU로 데이터를 가져와라

- PUSH : 스택에 데이터를 저장하라

- POP : 스택의 최상단 데이터를 가져와라

<br/><br/>

## 산술 / 논리 연산

- ADD :  덧셈 / 뺄셈 / 곱셈 / 나눗셈을 수행하라.

- INCREMENT : 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라

- AND / OR / NOT :  연산을 수행하라

- COMPARE :  두개의 숫자 또는 TRUE / FALSE 값을 비교하라

<br/><br/>

## 제어 흐름 변경

JUMP : 특정 주소로 실행 순서를 옮겨라

HALT : 프로그램의 실행을 멈춰라

CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라

<br/><br/>

## 입출력 제어

READ : 특정 입출력 장치로부터 데이터를 읽어라

WRITE : 특정 입출력 장치로 데이터를 써라

START IO : 입출력 장치를 시작하라

TEST IO : 입출력 장치의 상태를 확인하라


<br/><br/>

## 주소지정 방식

유효주소를 찾는 방법은 5가지가 있다.

- 즉시 주소 지정 방식

    - 연산에 사용할 데이터를 직접 명시하는 방식 (굉장히 빠르지만 너무 공간이 한정적)

- 직접 주소 지정 방식

    - 오퍼랜드 필드에 유효주소를 직접적으로 명시한다.

    - 표현할 수 있는 데이터 크기는 즉시 주소 지정방식보다 커졌지만, 유효주소 표현 범위가 제한이 있다.

- 간접 주소 지정 방식

    - 유효주소의 주소를 오퍼랜드 필드에 명시

    - 두번의 메모리 접근이 필요해서 위의 방식들보다 느리다.

- 레지스터 주소 지정 방식

    - 연산에 사용할 데이터가 레지스터에 저장된 경우도 있다.

    - 연산에 사용할 데이터가 저장된 레지스터를 오퍼랜드 필드에 직접 명시하는 방법

    - CPU 외부 메모리접근하는 것보다는, CPU 내부 레지스터에 접근하는게 더 빠르다

    - 레지스터 크기에 제한이 생길 수 있다. 

- 레지스터 간접 주소 지정 방식

    - 연산에 사용할 데이터를 메모리에 저장하고, 그 주소를 저장한 레지스터를 오퍼랜드필드에 명시하는 방법

    - 간접 주소 지정방식과 비슷하지만, 메모리에 접근하는 횟수가 한번으로 줄어든다.

    - 따라서 간접 주소 지정방식보다 빠르다!



<br/><br/>

## 상식

```jsx
CPU가 메모리에 접근하는 속도보다 레지스터에 접근하는 속도가 훨씬 빠르다
- 왜? 메모리는 CPU 밖에 있다. 하지만 레지스터는 CPU 안에 있기 때문이다.
```

- 연산에 사용할 데이터가 저장된 레지스터 명시

- 메모리에 접근하는 속도보다 레지스터에 접근하는 것이 빠르다


<br/><br/><br/><br/>


참고 : https://jie0025.tistory.com/478