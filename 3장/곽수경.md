# 소스 코드와 명령어

컴퓨터 = 명령어를 처리하는 기계

C, C++, Java, Python은 명령어 인가? 
→ 아님, 모든 소스 코드(C, C++, Python)은 컴퓨터 내부에서 명령어로 변환됨

## 고급 언어 / 저급 언어

- 고급 언어
    - 사람을 위한 언어
    - C, C++, Python 등

- 저급 언어
    - 컴퓨터가 이해하고 실행할 수 있는 언어
    - 명령어

### 저급 언어

- 기계어
    - 2진수나 16진수로 표현된 언어
    - 오직 컴퓨터만을 위해 만들어진 언어

- 어셈블리어 
    - 기계어를 읽기 편한 형태로 번역한 언어
    - 어셈블리어의 한 줄 한 줄이 명령어

## 컴파일 언어 / 인터프리터 언어

- 고급 언어는 결국 저급 언어로 변환되어 실행됨
    - 변환되는 방식에 컴파일 방식, 인터프리터 방식이 있음

### 컴파일 언어

- 컴파일(compile)
    - 소스 코드 전체를 저급 언어로 변환되는 과정
    - 컴파일러(compiler) : 컴파일을 수행하는 도구
    - 목적 코드(object code) : 컴파일을 통해 나온 결과물
- 컴파일러는 전체 소스 코드를 훑으면서 
문법적인 오류는 없는지, 
실행 가능한 코드인지, 
실행하는데 불필요한 코드는 없는지 등을 검토
- 오류를 하나라도 발견하면 해당 소스 코드는 컴파일에 실패함

### 인터프리터 언어

- 인터프리터(interpreter)
    - 소스 코드를 한 줄씩 저급 언어로 변환하여 실행하는 도구
- 소스 코드 전체를 저급 언어로 변환하는 시간을 기다릴 필요가 없음
- N번째 줄에서 오류를 발견하더라도 N-1번째 줄 코드까지는 실행됨

> 일반적으로 인터프리터 언어가 컴파일 언어보다 느림
> 
> - 컴파일 언어의 목적 코드는 컴퓨터가 바로 이해하고 실행할 수 있지만
> - 인터프리터는 소스 코드를 한줄씩 저급 언어로 해석해야 하기 때문

> 모든 언어를 명확하게 컴파일 언어 / 인터프리터 언어로 구분할 순 없음
> 
> - C, C++ 같이 명확하게 컴파일 언어라고 구분할 수 있는 언어도 있음
> - Python은 인터프리터 언어지만 부분적으로 컴파일을 수행함
> - Java는 저급언어가 되는 과정에서 컴파일과 인터프리트를 동시에 수행함

<aside>
<b>목적 파일 / 실행 파일</b>

- 목적 파일 : 목적 코드(object code)로 이루어진 파일
- 실행 파일 : 실행 코드(excutable code)로 이루어진 파일
- 링킹 : 해당 파일에 없는 외부 기능들(ex. 다른 파일에 정의되어 있는 함수)을 연결 짓는 작업


</aside>

# 명령어의 구조

어셈블리어로 표현된 명령어들의 구조 알아보기

## 연산 코드와 오퍼랜드

- 명령어
    
    = 수행할 동작(연산) + 명령 대상 
    
    = 연산자 + 피연산자
    
    = 연산 코드(operation code) + 오퍼랜드(operand)
    
- 오퍼랜드가 담기는 영역 = 오퍼랜드 필드 
  
  연산 코드가 담기는 영역 = 연산 코드 필드

### 오퍼랜드

- 오퍼랜드 = 연산에 사용할 데이터 / 연산에 사용할 데이터가 저장된 위치
- 오퍼랜드 필드에는 주로 값이 명시되기보단 사용할 데이터가 저장된 위치가 담김
    - 주로 위치가 담기기 때문에 오퍼랜드 필드를 **주소 필드**라고도 함
- 오퍼랜드 개수에 따른 명령어 명칭
    - 0-주소 명령어, 1-주소 명령어, 2-주소 명령어, 3-주소 명령어

### 연산 코드

- 연산 코드 종류
    
    
    1. **데이터 전송**
        - MOVE
            
            데이터 옮겨라
            
        - STORE
            
            메모리에 저장하라
            
        - LOAD(FETCH)
            
            메모리에서 CPU로 데이터를 가져와라
            
        - PUSH
            
            스택에 데이터를 저장하라
            
        - POP
            
            스택의 최상단 데이터를 가져와라
            
    
    1. **산술/논리 연산**
        - ADD / SUBTRACT / MULTIPLY / DIVIDE
            
            사칙연산 수행하라
            
        - INCREMENT / DECREMENT
            
            오퍼랜드에 1 더하라 / 1을 빼라
            
        - AND / OR / NOT
            
            논리 연산 수행하라
            
        - COMPARE
            
            두개 숫자 또는 TRUE / FALSE 비교하라
            
    
    1. **제어 흐름 변경**
        - JUMP
            
            특정 주소로 실행 순서를 옮겨라
            
        - CONDITIONAL JUMP
            
            주건에 부합할 때 특정 주소로 실행 순서를 옮겨라
            
        - HALT
            
            프로그램의 실행을 멈춰라
            
        - CALL
            
            되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
            
        - RETURN
            
            CALL을 호출할 때 저장했던 주소로 돌아가라
            
    
    1. **입출력 제어**
        - READ (INPUT)
            
            특정 입출력 장치로부터 데이터를 읽어라
            
        - WRITE (OUTPUT)
            
            특정 입출력 장치로 데이터를 써라
            
        - START IO
            
            입출력 장치를 시작하라
            
        - TEST IO
            
            입출력 장치의 상태를 확인하라
            
    

## 주소 지정 방식

- 오퍼랜드 필드에 주소를 담는 이유
    - 명령어의 길이 때문 → 제한된 비트에 정보를 담아야 하기 때문
    - 주소를 담게되면 저장 공간이 메모리의 크기만큼 or 담는 레지스터의 크기 커짐
- 이렇게 주소를 담을 때 데이터가 저장되는 주소(저장된 위치)를 유효 주소(effective address)라고 함
- 연산에 사용할 데이터 위치를 찾는 방법을 **주소 지정 방식(addressing mode)**라고 함

### 1. 즉시 주소 지정 방식 (immediate addressing mode)

- 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식
- 저장할 수 있는 데이터의 크기가 작음
- 데이터를 메모리나 레지스터에서 찾아올 필요가 없기 때문에 다른 방식들보다 빠름

### 2. 직접 주소 지정 방식 (direct addressing mode)

- 오퍼랜드 필드에 유효 주소(메모리 주소)를 직접 명시하는 방식
- 저장할 수 있는 데이터 크기는 커졌지만 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 줄어듬

### 3. 간접 주소 지정 방식 (indirect addressing mode)

- `유효 주소`의 주소(메모리 주소)를 오퍼랜드 필드에 명시
- 직접 주소 지정 방식보다 저장할 수 있는 유효 주소의 범위가 커짐
- 메모리 접근을 2번 해야함 → 앞선 방법들 보다 느림

### 4. 레지스터 주소 지정 방식

- 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방식
- 메모리(CPU 외부)보다 레지스터(CPU 내부)에 접근하는 것이 더 빠름
- 저장할 수 있는 레지스터(의 이름) 크기에 제한이 있음

### 5. 레지스터 간접 주소 지정 방식

- 연산에 사용할 데이터를 메모리에 저장 → 메모리 주소를 레지스터에 저장 → 레지스터를 오퍼랜드 필드에 저장
- 간접 주소 지정 방식과 비슷함
    - 간접 주소 지정 방식 : 메모리에 2번 접근
    - 레지스터 간접 주소 지정 방식 : 레지스터에 1번, 메모리에 1번 접근 → 더 빠름