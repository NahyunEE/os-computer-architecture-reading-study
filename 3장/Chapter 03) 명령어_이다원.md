# Chapter 03) 명령어

## 03-1) 소스코드와 명령어

### 고급언어와 저급언어

고급언어 : 개발자가 이해하기 쉽게 만든 언어(Java, C, C++)

저급언어 : 컴퓨터가 이해하고 실행하는 언어

- 기계어 : 0과 1로 이루어진 명령어 (2진수/16진수)
- 어셈블리어 : 0과 1로 이루어진 기계어를 사람들이 읽기 편한 형태로 번역한 저급언어

### 고급언어가 저급언어로 변환되는 방식

**1) 컴파일 방식**

고급언어로 작성된 **소스 코드는 컴파일러에 의해 저급 언어로 변환**되고 (**컴파일**) **컴파일의 결과로 저급 언어인 목적 코드가 생성 된다.** 

- 소스코드 컴파일 중 오류가 발생하면 소스 코드 전체가 실행되지 않는다.

**2) 인터프리트 방식**

인터프리터에 의해 한 줄씩 실행한다. 

소스 코드 전체가 저급 언어로 변환되기까지 기다릴 필요가 없다. 

- 소스 코드 인터프리트 중 오류가 발생하면 오류 발생 전까지 코드는 실행

**목적파일 VS 실행파일** 

목적파일 : 저급언어로 이루어진 파일 

목적코드가 실행 파일이 되기 위해서는 **링킹**이라는 작업이 필요하다 

**링킹** : 다른 기능 파일을 main파일과 연결 짓는 작업

## 03-2) 명령어의 구조

### 연산코드와 오퍼랜드

**오퍼랜드(피연산자**) : 연산에 사용할 데이터 혹은 데이터의 위치 

- 오퍼랜드 필드(= 주소필드)에는 사실 연산에 사용될 데이터가 저장된 위치가 더 많이 사용된다.

오퍼랜드는 명령어 안에 하나도 없을 수도 있다. 

- 0-주소 명령어 : 오퍼랜드가 하나도 없는 명령어
- 1-주소 명령어 : 오퍼랜드가 한개인 명령어
- 2-주소 명령어 : 두개
- 3-주소 명령어 : 세개

**연산코드(연산자)** : 명령어가 수행할 연산 

기본적인 연산 코드 유형은 다음과 같다 

- 데이터 전송
- 산술/논리 연산
- 제어 흐름 변경
- 입출력 제어

1) 데이터 전송 

- MOVE : 데이터를 옮겨라
- STORE : 메모리에 저장하라
- LOAD(FETCH) : 메모리에서 CPU로 데이터를 가져와라
- PUSH : 스택에 데이터를 저장하라
- POP : 스택의 최상단 데이터를 가져와라

2) 산술/논리 연산 

- ADD / SUBTRACT / MULTIPLY / DIVIDE : 덧셈/ 뺄셈 / 곱셈 / 나눗셈
- INCREMENT / DEVREMENT : 오퍼랜드에 +1 / -1 하라
- AND / OR / NOT: AND / OR / NOT  :  연산을 수행하라
- COMPARE : 두개의 숫자 또는 TRUE / FALSE 값을 비교하라

3) 제어 흐름 변경

- JUMP : 특정 주소로 실행 순서를 옮겨라
- CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
- HALT : 프로그램의 실행을 멈춰라
- CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
- RETURN : CALL을 호출할 때 저장했던 주소로 돌아가라

4) 입출력 제어 

- READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라
- WRITE(OUTPUT) : 특정 입출력 장치로 데이터를 써라
- START IO : 입출력 장치를 시작하라
- TEST IO : 입출력 장치의 상태를 확인하라

### 주소 지정 방식

왜 오퍼랜드 필드에 메모리나 레지스터의 주소를 담는 것일까? 

그냥 데이터 그 자체를 넣으면 되는 것 아닐까?

- 명령어 내에서 표현할 수 있는 **데이터의 크기가 제한**되기 때문이다.

**명령어 주소 지정 방식**

오퍼랜드에서 명령어의 주소 위치를 지정하게 된다면(=유효주소) 기존 오퍼랜드에서 가진 메모리 크기 보다 더 많은 크기를 할당받을 수 있다. 

→ 오퍼랜드 필드에 연산에 사용되는 데이터가 저장된 위치

- 유효주소(effective address) : 연산에 사용할 데이터가 저장된 위치
- 연산에 사용할 데이터가 저장된 위치를 찾는 방법
- 유효 주소를 찾는 방법
- 다양한 명령어 주소 지정 방식들

**즉시 주소 지정 방식(immediate addressing mode)**

- 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
- 가장 간단한 형태의 주소 지정 방식
- 연산에 사용할 데이터의 크기가 작아질 수 있지만 빠르다.
- 단점 : 연산에 사용될 데이터가 제한될 수 있다.

**직접 주소 지정 방식(direct addressing mode)**

- 오퍼랜드 필드에 유효 주소 직접적으로 명시
- 유효 주소를 표현할 수 있는 크기가 연산 코드만큼 줄어

**간접 주소 지정 방식(direct addressing mode)**

- 오퍼랜드 필드에 유효 주소의 주 직접적으로 명시
- 앞선 주소 지정 방식들에 비해 속도가 느리다.

메모리 접근을 최소화하는 것이 속도면에서 좋다~ 

**레지스터 주소 지정 방식(register addressing mode)**

- 연산에 사용할 데이터가 저장된 레지스터 명시
- **메모리에 접근하는 속도보다 레지스터에 접근하는 것이 빠름 → 중요**

(메모리는 CPU밖에 있지만 레지스터는 CPU 안에 위치하기 때문이다) 

**레지스터 간접 주소 지정 방식(register indirect addressing mode)**

- 연산에 사용할 데이터를 메모리에 저장
- 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시